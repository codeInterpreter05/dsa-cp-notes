TRAVERSAL IN DOUBLY LINKED LISTS

1. Traverse the Linked List (Forward)  
   Algorithm:  
     1. Start from the head node.  
     2. While the current node is not NULL:  
         - Process the data of the current node (e.g., print it).  
         - Move to the next node by updating the pointer to `current = current->next`.  
   Time Complexity: O(N) (where N is the number of nodes in the list)  
   Space Complexity: O(1)  

2. Traverse the Linked List (Backward)  
   Algorithm:  
     1. Start from the tail node.  
     2. While the current node is not NULL:  
         - Process the data of the current node (e.g., print it).  
         - Move to the previous node by updating the pointer to `current = current->prev`.  
   Time Complexity: O(N)  
   Space Complexity: O(1)  

----------------------------------------------------

INSERTIING A NODE

1. Insert at the Beginning  
   Algorithm:  
     1. Create a new node with the given data.  
     2. If the list is empty (`head == NULL`):  
         - Set `head = newNode` and `tail = newNode`.  
         - Update `newNode->next = NULL` and `newNode->prev = NULL`.  
     3. Else:  
         - Set `newNode->next = head`.  
         - Set `head->prev = newNode`.  
         - Update `head = newNode`.  
   Time Complexity: O(1)  
   Space Complexity: O(1)  

2. Insert at the End  
   Algorithm:  
     1. Create a new node with the given data.  
     2. If the list is empty (`head == NULL`):  
         - Set `head = newNode` and `tail = newNode`.  
         - Update `newNode->next = NULL` and `newNode->prev = NULL`.  
     3. Else:  
         - Set `tail->next = newNode`.  
         - Set `newNode->prev = tail`.  
         - Update `tail = newNode`.  
   Time Complexity: O(1)  
   Space Complexity: O(1)  

3. Insert at a Specific Position  
   Algorithm:  
     1. Traverse the list to find the desired position.  
     2. Create a new node with the given data.  
     3. Update pointers:  
         - Set `newNode->next = current->next`.  
         - Set `current->next->prev = newNode`.  
         - Set `current->next = newNode`.  
         - Set `newNode->prev = current`.  
   Time Complexity: O(N)  
   Space Complexity: O(1)  

4. Insert After a Given Node  
   Algorithm:  
     1. Find the node after which insertion is required.  
     2. Create a new node with the given data.  
     3. Update pointers:  
         - Set `newNode->next = givenNode->next`.  
         - If `givenNode->next` is not NULL, update `givenNode->next->prev = newNode`.  
         - Set `givenNode->next = newNode`.  
         - Set `newNode->prev = givenNode`.  
   Time Complexity: O(1)  
   Space Complexity: O(1)  

5. Insert Before a Given Node  
   Algorithm:  
     1. Find the node before which insertion is required.  
     2. Create a new node with the given data.  
     3. Update pointers:  
         - Set `newNode->prev = givenNode->prev`.  
         - If `givenNode->prev` is not NULL, update `givenNode->prev->next = newNode`.  
         - Set `givenNode->prev = newNode`.  
         - Set `newNode->next = givenNode`.  
   Time Complexity: O(1)  
   Space Complexity: O(1)  

------------------------------------------------

DELETION OPERATIONS

1. Delete from the Beginning  
   Algorithm:  
     1. If the list is empty (`head == NULL`):  
         - Return; there is nothing to delete.  
     2. Update `head = head->next`.  
     3. If `head` is not NULL, set `head->prev = NULL`.  
     4. If `head == NULL`, set `tail = NULL`.  
     5. Free the memory of the deleted node.  
   Time Complexity: O(1)  
   Space Complexity: O(1)  

2. Delete from the End  
   Algorithm:  
     1. If the list is empty (`head == NULL`):  
         - Return; there is nothing to delete.  
     2. Update `tail = tail->prev`.  
     3. If `tail` is not NULL, set `tail->next = NULL`.  
     4. If `tail == NULL`, set `head = NULL`.  
     5. Free the memory of the deleted node.  
   Time Complexity: O(1)  
   Space Complexity: O(1)  

3. Delete from a Specific Position  
   Algorithm:  
     1. Traverse the list to find the desired position.  
     2. Update pointers:  
         - Set `current->prev->next = current->next`.  
         - Set `current->next->prev = current->prev`.  
     3. Free the memory of the deleted node.  
   Time Complexity: O(N)  
   Space Complexity: O(1)  

4. Delete After a Given Node  
   Algorithm:  
     1. Find the node after which deletion is required.  
     2. If `givenNode->next` is NULL, return; nothing to delete.  
     3. Update pointers:  
         - Set `givenNode->next = givenNode->next->next`.  
         - If `givenNode->next` is not NULL, update `givenNode->next->prev = givenNode`.  
     4. Free the memory of the deleted node.  
   Time Complexity: O(1)  
   Space Complexity: O(1)  

5. Delete Before a Given Node  
   Algorithm:  
     1. Find the node before which deletion is required.  
     2. If `givenNode->prev` is NULL, return; nothing to delete.  
     3. Update pointers:  
         - Set `givenNode->prev = givenNode->prev->prev`.  
         - If `givenNode->prev` is not NULL, update `givenNode->prev->next = givenNode`.  
     4. Free the memory of the deleted node.  
   Time Complexity: O(1)  
   Space Complexity: O(1)  
