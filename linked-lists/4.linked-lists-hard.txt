1) REVERSE NODES IN K-GROUPS IN A DOUBLY LINKED LIST

Brute Force Approach

1. Store Nodes in an Array
   - Traverse the list and store all node addresses in an array.

2. Reverse in Groups
   - Iterate through the array in groups of `k`, reversing the connections manually.

3. Reconnect the List
   - Update `next` and `prev` pointers for all nodes after reversing.

4. Edge Cases
   - If `k == 1`, no reversal is needed.
   - If the list has fewer than `k` nodes, return as is.

5. Time Complexity
   - O(N), as we traverse and process each node once.

6. Space Complexity
   - O(N), due to storing all node addresses in an array.


Optimal Approach (In-Place Reversal)

1. Traverse and Count Nodes
   - Count the number of nodes to check if k-group reversal is possible.

2. Reverse k Nodes Iteratively
   - For each group of `k` nodes:
     - Swap `next` and `prev` pointers within the group.
     - Update `prev_group_tail->next` to connect groups.
   - Move to the next group.

3. Handle Remaining Nodes
   - If the remaining nodes are less than `k`, keep them as is.

4. Edge Cases
   - The list has fewer than `k` nodes.
   - `k == 1`, meaning no change.
   - The list is empty.

5. Time Complexity
   - O(N), as each node is visited once.

6. Space Complexity
   - O(1), since reversal is done in place.

----------------------------------------------------------

2) ROTATE A LINKED LIST BY K TIMES

Brute Force Approach

1. Rotate One Node at a Time
   - For each of the `k` rotations:
     - Traverse to the last node.
     - Make the last node the new head and update pointers.

2. Time Complexity
   - O(k * N), since we traverse the list `k` times.

3. Space Complexity
   - O(1), as no extra space is used.


Optimal Approach

1. Find the Length
   - Traverse the list to get the total number of nodes (`N`).

2. Optimize k
   - Since rotating `N` times results in the same list, update `k = k % N`.

3. Find the New Head
   - Traverse to the `(N-k)th` node.
   - Update its `next` to NULL (new tail).
   - The next node becomes the new head.

4. Update the Last Node
   - Connect the last node to the old head.

5. Time Complexity
   - O(N), as we traverse the list only twice.

6. Space Complexity
   - O(1), since rotation is done in place.
