1) FINDING THE MIDDLE NODE OF A LINKED LIST

Brute Force Approach

1. Count the Nodes
   - Traverse the linked list and count the total number of nodes (`count`).

2. Traverse Again to the Middle
   - Traverse the list again, stopping at the middle node (`count / 2`).

3. Time Complexity
   - O(N), where N is the number of nodes.

4. Space Complexity
   - O(1), as no extra space is used.


Tortoise-Hare Method

1. Initialize Two Pointers
   - Use two pointers:
     - `slow` moves one step at a time.
     - `fast` moves two steps at a time.

2. Traverse the List
   - While `fast != NULL` and `fast->next != NULL`:
     - Move `slow` one step forward.
     - Move `fast` two steps forward.

3. Middle Node
   - When `fast` reaches the end, `slow` will point to the middle node.

4. Time Complexity
   - O(N), as the list is traversed once.

5. Space Complexity
   - O(1), as no extra space is used.

----------------------------------------------------

2) ADD TWO NUMBERS REPRESENTED BY LINKED LISTS

Brute Force Approach

1. Reverse Both Linked Lists
   - Reverse both input linked lists.
   
2. Add the Digits
   - Traverse both lists and add the digits, considering the carry.
   - Create a new list to store the result.
   
3. Reverse the Result
   - Reverse the result list before returning.

4. Time Complexity
   - O(N), where N is the maximum length of the two linked lists.

5. Space Complexity
   - O(N), where N is the number of digits in the result list.


Optimized Approach (Without Reversing the Lists)

1. Traverse Both Lists
   - Traverse both linked lists simultaneously.
   
2. Add Corresponding Digits
   - Add the digits from both lists and handle the carry.
   - If one list is shorter, consider its missing digits as 0.
   
3. Create the Result List
   - Add the sum to a new linked list.
   
4. Time Complexity
   - O(N), where N is the maximum length of the two linked lists.

5. Space Complexity
   - O(N), where N is the length of the result list.

-----------------------------------------------------------

3) ODD EVEN LINKED LIST

Brute Force Approach

1. Traverse the List and Separate Odd and Even Nodes
   - Traverse the linked list and separate the odd and even indexed nodes into two different lists.

2. Merge the Lists
   - Connect the tail of the odd list to the head of the even list.

3. Time Complexity
   - O(N), where N is the number of nodes.

4. Space Complexity
   - O(N), as extra space is used for storing even and odd lists.


Optimized Approach (One Pass)

1. Initialize Three Pointers
   - `odd` for the head of the odd indexed list.
   - `even` for the head of the even indexed list.
   - `evenHead` to store the head of the even list for later.

2. Traverse the List
   - Traverse the list and rearrange the pointers such that all odd-indexed nodes are grouped together, followed by the even-indexed nodes.

3. Merge the Lists
   - Connect the last odd node to the head of the even list.

4. Time Complexity
   - O(N), where N is the number of nodes.

5. Space Complexity
   - O(1), as no extra space is used.


----------------------------------------------------------------------

4) SORT A LINKED LIST OF 0s, 1s, AND 2s

Brute Force Approach

1. Traverse the List and Count the Occurrences
   - Traverse the linked list and count the occurrences of 0s, 1s, and 2s.

2. Reconstruct the List
   - Create a new linked list and append the correct number of 0s, 1s, and 2s in the correct order.

3. Time Complexity
   - O(N), where N is the number of nodes.

4. Space Complexity
   - O(N), as a new list is created to store the sorted nodes.


Optimized Approach (Three-Pointer Method)

1. Initialize Three Pointers and Dummy Nodes
   - Create three dummy nodes: `zero_head`, `one_head`, and `two_head`.
   - Create pointers `zero`, `one`, and `two` to manage these lists.

2. Traverse the List and Segregate Nodes
   - Traverse the linked list and place each node into one of the three lists based on its value.

3. Merge the Three Lists
   - Connect the tail of the 0s list to the head of the 1s list.
   - Connect the tail of the 1s list to the head of the 2s list.
   - Ensure the last node of the 2s list points to NULL.

4. Time Complexity
   - O(N), where N is the number of nodes.

5. Space Complexity
   - O(1), as no extra space is used apart from the dummy nodes.


Optimized Approach (Dutch National Flag Algorithm)

1. Initialize Three Pointers
   - `low`: points to the first element of the list, for 0s.
   - `mid`: points to the current element being processed.
   - `high`: points to the last element of the list, for 2s.

2. Traverse the List
   - While `mid` is less than or equal to `high`:
     - If `mid->data == 0`, swap `low` and `mid` and move both pointers forward.
     - If `mid->data == 1`, move `mid` forward.
     - If `mid->data == 2`, swap `mid` and `high` and move `high` backward.

3. Time Complexity
   - O(N), where N is the number of nodes.

4. Space Complexity
   - O(1), as no extra space is used.

----------------------------------------------------------

5) DELETE N-th NODE FROM THE END OF A LINKED LIST

Brute Force Approach

1. Count the Total Nodes
   - Traverse the linked list to count the total number of nodes (`count`).

2. Find the Node to Delete
   - The N-th node from the end is at position `(count - N + 1)` from the start.

3. Traverse Again and Delete
   - Traverse again to this position and delete the node.

4. Time Complexity
   - O(N), where N is the number of nodes.

5. Space Complexity
   - O(1), as no extra space is used.


Optimized Approach (Two-Pointer Method)

1. Initialize Two Pointers
   - `fast` and `slow`, both pointing to the head.

2. Move `fast` N Steps Ahead
   - Move `fast` N steps ahead.

3. Move Both Pointers Until `fast` Reaches the End
   - Move `slow` and `fast` one step at a time.
   - When `fast` reaches the last node, `slow` is at `(N+1)`-th node from the end.

4. Delete the N-th Node
   - Adjust the `next` pointer of `slow` to skip the N-th node.

5. Edge Case: If N is Equal to the Length of the List
   - If `fast` reaches NULL after moving N steps, delete the head node.

6. Time Complexity
   - O(N), as the list is traversed once.

7. Space Complexity
   - O(1), as no extra space is used.
