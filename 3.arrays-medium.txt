1) LONGEST SUBARRAY WITH SUM K  

ALGORITHM - BRUTE FORCE  
1. Initialize `maxLen = 0`.  
2. Use two nested loops:  
   - Outer loop from `i = 0` to `n-1`.  
   - Initialize `currentSum = 0`.  
   - Inner loop from `j = i` to `n-1`:  
     - Add `arr[j]` to `currentSum`.  
     - If `currentSum == k`, update `maxLen = max(maxLen, j - i + 1)`.  
3. Return `maxLen`.  

TIME COMPLEXITY: O(N²)  
SPACE COMPLEXITY: O(1)  

----------------------------------------  

ALGORITHM - OPTIMAL (Using Hash Map)  
1. Initialize `prefixSum = 0` and an empty hash map `prefixMap`.  
2. Initialize `maxLen = 0`.  
3. Traverse the array from `i = 0` to `n-1`:  
   - Add `arr[i]` to `prefixSum`.  
   - If `prefixSum == k`, update `maxLen = i + 1`.  
   - If `prefixSum - k` exists in `prefixMap`, update:  
     `maxLen = max(maxLen, i - prefixMap[prefixSum - k])`.  
   - If `prefixSum` is not in `prefixMap`, store it with its index `i`.  
4. Return `maxLen`.  

TIME COMPLEXITY: O(N)  
SPACE COMPLEXITY: O(N)  

----------------------------------------  

ALGORITHM - OPTIMAL (Using Two Pointers) - Only for Positive Numbers  
1. Initialize two pointers `start = 0` and `end = 0`.  
2. Initialize `currentSum = 0` and `maxLen = 0`.  
3. Traverse the array while `end < n`:  
   - Add `arr[end]` to `currentSum`.  
   - While `currentSum > k`, subtract `arr[start]` and increment `start`.  
   - If `currentSum == k`, update `maxLen = max(maxLen, end - start + 1)`.  
   - Increment `end`.  
4. Return `maxLen`.  

TIME COMPLEXITY: O(N)  
SPACE COMPLEXITY: O(1)  

----------------------------------------  

2) TWO SUM PROBLEM  

ALGORITHM - BRUTE FORCE  
1. Use two nested loops:  
   - Outer loop from `i = 0` to `n-2`.  
   - Inner loop from `j = i+1` to `n-1`:  
     - If `arr[i] + arr[j] == target`, return indices `(i, j)`.  
2. If no such pair is found, return `-1`.  

TIME COMPLEXITY: O(N²)  
SPACE COMPLEXITY: O(1)  

----------------------------------------  

ALGORITHM - OPTIMAL (Using Hash Map)  
1. Initialize an empty hash map `hashMap`.  
2. Traverse the array from `i = 0` to `n-1`:  
   - Calculate `complement = target - arr[i]`.  
   - If `complement` exists in `hashMap`, return indices `(hashMap[complement], i)`.  
   - Otherwise, store `arr[i]` with its index `i` in `hashMap`.  
3. If no such pair is found, return `-1`.  

TIME COMPLEXITY: O(N)  
SPACE COMPLEXITY: O(N)  

----------------------------------------  

ALGORITHM - OPTIMAL (Two Pointers - Sorted Array)  
*Note: This approach works only if the array is sorted.*  

1. Sort the array (if not already sorted).  
2. Initialize two pointers: `left = 0` and `right = n - 1`.  
3. While `left < right`:  
   - Calculate `currentSum = arr[left] + arr[right]`.  
   - If `currentSum == target`, return indices `(left, right)`.  
   - If `currentSum < target`, increment `left` by 1.  
   - If `currentSum > target`, decrement `right` by 1.  
4. If no such pair is found, return `-1`.  

TIME COMPLEXITY: O(N log N) (due to sorting)  
SPACE COMPLEXITY: O(1)  

----------------------------------------  

3) SORT AN ARRAY OF 0s, 1s, AND 2s  

ALGORITHM - BRUTE FORCE (Using Sorting)  
1. Sort the array using a built-in sorting function.  
2. Return the sorted array.  

TIME COMPLEXITY: O(N log N)  
SPACE COMPLEXITY: O(1)  

----------------------------------------  

ALGORITHM - OPTIMAL (Dutch National Flag Algorithm)  
1. Initialize three pointers:  
   - `low = 0`, `mid = 0`, and `high = n - 1`.  
2. While `mid <= high`:  
   - If `arr[mid] == 0`:  
     - Swap `arr[low]` and `arr[mid]`.  
     - Increment `low` and `mid`.  
   - Else if `arr[mid] == 1`:  
     - Increment `mid`.  
   - Else if `arr[mid] == 2`:  
     - Swap `arr[mid]` and `arr[high]`.  
     - Decrement `high`.  
3. Return the sorted array.  

TIME COMPLEXITY: O(N)  
SPACE COMPLEXITY: O(1)  

----------------------------------------  

4) MAJORITY ELEMENT (Element appearing more than ⌊N/2⌋ times)  

ALGORITHM - BRUTE FORCE (Count Frequency)  
1. Traverse the array for each element:  
   - Count its occurrences in the array.  
   - If the count exceeds ⌊N/2⌋, return the element.  
2. If no element satisfies the condition, return `-1`.  

TIME COMPLEXITY: O(N²)  
SPACE COMPLEXITY: O(1)  

----------------------------------------  

ALGORITHM - OPTIMAL (Using Hash Map)  
1. Initialize an empty hash map `hashMap`.  
2. Traverse the array:  
   - Increase the count of the current element in `hashMap`.  
   - If the count of any element exceeds ⌊N/2⌋, return that element.  
3. If no element satisfies the condition, return `-1`.  

TIME COMPLEXITY: O(N)  
SPACE COMPLEXITY: O(N)  

----------------------------------------  

ALGORITHM - OPTIMAL (Boyer-Moore Voting Algorithm)  
1. Initialize `count = 0` and `candidate = -1`.  
2. Traverse the array:  
   - If `count == 0`, set `candidate = arr[i]`.  
   - If `arr[i] == candidate`, increment `count`.  
   - Else, decrement `count`.  
3. Perform a second pass to confirm the candidate’s frequency (optional if guaranteed).  
4. Return `candidate` if valid; otherwise, return `-1`.  

TIME COMPLEXITY: O(N)  
SPACE COMPLEXITY: O(1)  

----------------------------------------  

5) MAXIMUM SUBARRAY SUM  

ALGORITHM - BRUTE FORCE (Check All Subarrays)  
1. Initialize `maxSum = -∞`.  
2. Use two nested loops:  
   - Outer loop from `i = 0` to `n-1`.  
   - Inner loop from `j = i` to `n-1`:  
     - Calculate the sum of subarray `arr[i:j+1]`.  
     - Update `maxSum = max(maxSum, currentSum)`.  
3. Return `maxSum`.  

TIME COMPLEXITY: O(N²)  
SPACE COMPLEXITY: O(1)  

----------------------------------------  

ALGORITHM - OPTIMAL (Kadane's Algorithm)  
1. Initialize `maxSum = -∞` and `currentSum = 0`.  
2. Traverse the array from `i = 0` to `n-1`:  
   - Add `arr[i]` to `currentSum`.  
   - Update `maxSum = max(maxSum, currentSum)`.  
   - If `currentSum < 0`, reset `currentSum = 0`.  
3. Return `maxSum`.  

TIME COMPLEXITY: O(N)  
SPACE COMPLEXITY: O(1)  

----------------------------------------  

6) REARRANGE ARRAY ELEMENTS BY SIGN  

ALGORITHM - BRUTE FORCE (Separate Arrays)  
1. Initialize two arrays `positive[]` and `negative[]`.  
2. Traverse the array:  
   - If `arr[i] > 0`, add to `positive[]`.  
   - Else, add to `negative[]`.  
3. Reconstruct the array by alternating elements from `positive[]` and `negative[]`.  

TIME COMPLEXITY: O(N)  
SPACE COMPLEXITY: O(N)  

----------------------------------------  

ALGORITHM - OPTIMAL (Two Pointers In-Place)  
1. Initialize two pointers `pos = 0` and `neg = 1`.  
2. Create a result array `result[n]`.  
3. Traverse the array:  
   - If `arr[i] > 0`:  
     - Place `arr[i]` at `result[pos]`, increment `pos` by 2.  
   - If `arr[i] < 0`:  
     - Place `arr[i]` at `result[neg]`, increment `neg` by 2.  
4. Return the result array.  

TIME COMPLEXITY: O(N)  
SPACE COMPLEXITY: O(N)  

----------------------------------------  




