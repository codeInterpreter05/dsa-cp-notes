1) GENERATE ALL SUBSEQUENCES

Problem Statement  
- Given a string or array, generate all possible subsequences (subsets while maintaining order).

Brute Force Approach (Using Bit Manipulation)

1. Generate All Binary Masks
   - There are `2^N` possible subsequences.
   - Each bit represents whether to include an element.

2. Construct Subsequences
   - Iterate over all `2^N` combinations.
   - If the `i-th` bit is set, include the corresponding element.

3. Time Complexity
   - O(N * 2^N), as we generate `2^N` subsets, each taking O(N) time.

4. Space Complexity
   - O(1) (excluding output storage).


Optimal Approach (Using Recursion)

1. Recursive Function  
   - At each step, decide whether to include the current element.

2. Base Case  
   - When we reach the end of the string/array, store the current subsequence.

3. Recursive Calls  
   - Include the current element and recurse.
   - Exclude the current element and recurse.

4. Time Complexity  
   - O(2^N), as each element has two choices.

5. Space Complexity  
   - O(N), due to recursive call stack.

-------------------------------------------------------------------

2) COUNT SUBSEQUENCES WITH SUM K

Problem Statement  
- Given an array and an integer K, find the number of subsequences whose sum is exactly K.

Brute Force Approach (Using Power Set)

1. Generate All Subsequences  
   - Use bit manipulation or recursion to generate all subsequences.

2. Check Sum Condition  
   - For each subsequence, compute its sum.
   - If the sum equals K, increment the count.

3. Time Complexity  
   - O(N * 2^N), as we generate `2^N` subsequences and compute their sum in O(N).

4. Space Complexity  
   - O(1), excluding output storage.


Optimal Approach (Using Recursion)

1. Recursive Function  
   - At each step, decide whether to include the current element.

2. Base Case  
   - If we reach the end of the array:
     - If `sum == K`, return 1.
     - Else, return 0.

3. Recursive Calls  
   - Include the current element (`sum + arr[i]`).
   - Exclude the current element (`sum` remains unchanged).

4. Return the Total Count  
   - Count subsequences from both recursive calls.

5. Time Complexity  
   - O(2^N), as each element has two choices.

6. Space Complexity  
   - O(N), due to recursive call stack.

-----------------------------------------------

3) COMBINATION SUM

Problem Statement  
- Given an array of distinct integers and a target sum K, find all unique combinations where the chosen numbers sum to K.  
- Each number can be used multiple times.

Brute Force Approach (Using Power Set)

1. Generate All Subsequences  
   - Use bit manipulation or recursion to generate all possible subsequences.

2. Check Sum Condition  
   - For each subsequence, compute its sum.
   - If the sum equals K, store it.

3. Time Complexity  
   - O(N * 2^N), as we generate `2^N` subsequences and compute their sum in O(N).

4. Space Complexity  
   - O(N) for storing results (excluding recursion stack).


Optimal Approach (Using Recursion & Backtracking)

1. Recursive Function  
   - Maintain an index and current sum.
   - Try including the same element multiple times.

2. Base Case  
   - If `sum == K`, store the combination.
   - If `sum > K` or index goes out of bounds, return.

3. Recursive Calls  
   - Include `arr[i]` (keep index same, as repetition is allowed).
   - Exclude `arr[i]` (move to `i + 1` to avoid duplicate counts).

4. Time Complexity  
   - O(2^T * K), where T is the target sum and K is the average subset length.

5. Space Complexity  
   - O(K), for storing intermediate results in the recursion stack.

Backtracking ensures that we efficiently explore valid paths while avoiding unnecessary computations. ðŸš€ Let me know if you need a code example!
