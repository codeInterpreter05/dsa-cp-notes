1) MAX SIZE OF AN ARRAY

INSIDE int main() - 10 ^ 6
OUTSIDE int main() - 10 ^ 7

-----------------------------------------------

2) FIND LARGEST ELEMENT IN AN ARRAY  

ALGORITHM - BRUTE FORCE  
1. Sort the array in ascending order.  
2. Return the last element of the sorted array.  

TIME COMPLEXITY:  
- Sorting: O(N log N)  
- Accessing the last index: O(1)  
- Overall: O(N log N)  

SPACE COMPLEXITY:  
- Sorting typically requires extra memory: O(N).  


ALGORITHM - OPTIMAL  
1. Initialize `maxElement` to a very small value (e.g., -∞).  
2. Loop through each element in the array:  
   - Compare the current element with `maxElement`.  
   - If the current element is larger, update `maxElement`.  
3. After the loop, `maxElement` will hold the largest value.  

TIME COMPLEXITY:  
- Iterating through the array: O(N)  
- Overall: O(N).  

SPACE COMPLEXITY:  
- In-place comparison: O(1).  

----------------------------------------  

3) CHECK IF THE ARRAY IS SORTED  

ALGORITHM - BRUTE FORCE / OPTIMAL 
1. Iterate through the array from the first element to the second last element.  
2. Compare each element with the next element:  
   - If any element is greater than the next element, the array is not sorted.  
3. If the loop completes without finding any unsorted pair, the array is sorted.  

TIME COMPLEXITY:  
- Iterating through the array: O(N)  
- Overall: O(N)  

SPACE COMPLEXITY:  
- In-place comparison: O(1).  

----------------------------------------  

4) REMOVE DUPLICATES FROM SORTED ARRAY  

ALGORITHM - BRUTE FORCE  
1. Use a set to store the unique elements.  
2. Iterate through the array, adding each element to the set.  
3. The set will automatically handle duplicates, leaving only unique elements.  
4. Finally, return the set as the new array or convert the set back to an array.

TIME COMPLEXITY:  
- Iterating through the array: O(N)  
- Insertion into set (if sorted set): O(log N)  
- Overall (with sorted set): O(N log N)  
- If using hash set: O(1) on average for insertion, so overall is O(N).  

SPACE COMPLEXITY:  
- Space for the set: O(N).  


ALGORITHM - OPTIMAL  
1. Initialize two pointers:  
   - `i` (slow pointer) starts at the beginning of the array.  
   - `j` (fast pointer) iterates through the array.  
2. Compare the element at `arr[i]` with `arr[j]`.  
   - If they are different, increment `i` and set `arr[i] = arr[j]`.  
   - If they are the same, just move `j` to the next element.  
3. The array up to index `i` will contain only unique elements.  

TIME COMPLEXITY:  
- Iterating through the array: O(N)  
- Overall: O(N)  

SPACE COMPLEXITY:  
- No extra space required: O(1).  

----------------------------------------  

5) ROTATE ARRAY BY K POSITIONS  

ALGORITHM - BRUTE FORCE (Using a Temporary Array)  
1. Create a temporary array of the same size as the original array.  
2. Copy the last `k` elements of the original array into the beginning of the temporary array.  
3. Copy the remaining `n - k` elements of the original array into the end of the temporary array.  
4. Copy the elements from the temporary array back into the original array.  

TIME COMPLEXITY:  
- Copying elements to the temporary array: O(N)  
- Copying back to the original array: O(N)  
- Overall: O(N)  

SPACE COMPLEXITY:  
- Space for the temporary array: O(N).  


ALGORITHM - OPTIMAL (Reversal Algorithm)  
1. Normalize `k` to ensure it’s within the bounds of the array size (`k = k % n`), where `n` is the length of the array.  
2. Reverse the entire array.  
3. Reverse the first `k` elements.  
4. Reverse the remaining `n - k` elements.  

TIME COMPLEXITY:  
- Reversing the array: O(N)  
- Overall: O(N)  

SPACE COMPLEXITY:  
- In-place reversal: O(1).  

----------------------------------------  








